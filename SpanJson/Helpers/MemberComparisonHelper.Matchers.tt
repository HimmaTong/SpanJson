<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
namespace SpanJson.Helpers
{
    public static partial class MemberComparisonHelper
    {
<#
    for (int i = 1; i <= 64; i++)
    {
        List<string> values = new List<string>();
        List<int> sizes = new List<int>();
        int count = 0;
        var remaining = i;
        var ulongCount = Math.DivRem(remaining, 8, out remaining);
        for (int j = 0; j < ulongCount; j++)
        {
            values.Add("ulong " + (char) (count++ + 'a'));
            sizes.Add(sizeof(ulong));
        }

        var uintCount = Math.DivRem(remaining, 4, out remaining);
        for (int j = 0; j < uintCount; j++)
        {
            values.Add("uint " + (char) (count++ + 'a'));
            sizes.Add(sizeof(uint));
        }

        var ushortCount = Math.DivRem(remaining, 2, out remaining);
        for (int j = 0; j < ushortCount; j++)
        {
            values.Add("ushort " + (char) (count++ + 'a'));
            sizes.Add(sizeof(ushort));
        }

        var byteCount = Math.DivRem(remaining, 1, out remaining);
        for (int j = 0; j < byteCount; j++)
        {
            values.Add("byte " + (char) (count++ + 'a'));
            sizes.Add(sizeof(byte));
        }
        var arguments = string.Join(", ", values);
		var total = sizes.Sum();
#>
        public static bool IsMatch(in ReadOnlySpan<byte> span, <#=arguments#>)
        {
            ref var bStart = ref MemoryMarshal.GetReference(span);
			return span.Length == <#=total #>
<#
            for(int k = 0;k<sizes.Count;k++)
            {
            var currentArgument = (char) (k + 'a');
			var offset = sizes.Take(k).Sum();
			var size = "uint";
			if(sizes[k] == 1)
			{
		        size = "byte";
			}
			else if(sizes[k] == 2)
			{
			    size = "ushort";
			}
			else if(sizes[k] == 4)
			{
			    size = "uint";
			}
			else if(sizes[k] == 8)
			{
			    size = "ulong";
			}
			if(k == sizes.Count -1)
			{
#>
                && Unsafe.ReadUnaligned<<#=size#>>(ref Unsafe.Add(ref bStart, <#=offset #>)) == <#=currentArgument #>;
<#
            }
			else
			{
#>
                && Unsafe.ReadUnaligned<<#=size#>>(ref Unsafe.Add(ref bStart, <#=offset #>)) == <#=currentArgument #>
<#
			}
            }
#>
        }

<#
        }
#>
    }
}