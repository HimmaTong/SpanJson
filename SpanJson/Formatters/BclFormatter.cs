using System;
using System.Collections.Generic;
using SpanJson.Helpers;
using System.Buffers;
// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
namespace SpanJson.Formatters
{
    public sealed class StringUtf16Formatter : IJsonFormatter<String?, Char>
    {
        public static readonly StringUtf16Formatter Default = new StringUtf16Formatter();
        public void Serialize(ref JsonWriter<Char> writer, String? value)
        {
            if(value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            writer.WriteUtf16String(value);
        }

		public String? Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16String();
        }
    }

    public sealed class StringUtf16ArrayFormatter : IJsonFormatter<String?[]?, Char>
    {
        public static readonly StringUtf16ArrayFormatter Default = new StringUtf16ArrayFormatter();
        private static readonly StringUtf16Formatter ElementFormatter = StringUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, String?[]? value)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public String?[]? Deserialize(ref JsonReader<Char> reader)
        {
            String?[]? temp = null;
            String?[] result;
            try
            {
                temp = ArrayPool<String?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<String?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<String?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class StringUtf16ListFormatter : IJsonFormatter<List<String?>?, Char>
    {
        public static readonly StringUtf16ListFormatter Default = new StringUtf16ListFormatter();
        private static readonly StringUtf16Formatter ElementFormatter = StringUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<String?>? value)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public List<String?>? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<String?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class StringUtf8Formatter : IJsonFormatter<String?, Byte>
    {
        public static readonly StringUtf8Formatter Default = new StringUtf8Formatter();
        public void Serialize(ref JsonWriter<Byte> writer, String? value)
        {
            if(value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            writer.WriteUtf8String(value);
        }

		public String? Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8String();
        }
    }

    public sealed class StringUtf8ArrayFormatter : IJsonFormatter<String?[]?, Byte>
    {
        public static readonly StringUtf8ArrayFormatter Default = new StringUtf8ArrayFormatter();
        private static readonly StringUtf8Formatter ElementFormatter = StringUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, String?[]? value)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public String?[]? Deserialize(ref JsonReader<Byte> reader)
        {
            String?[]? temp = null;
            String?[] result;
            try
            {
                temp = ArrayPool<String?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<String?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<String?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class StringUtf8ListFormatter : IJsonFormatter<List<String?>?, Byte>
    {
        public static readonly StringUtf8ListFormatter Default = new StringUtf8ListFormatter();
        private static readonly StringUtf8Formatter ElementFormatter = StringUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<String?>? value)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public List<String?>? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<String?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class VersionUtf16Formatter : IJsonFormatter<Version?, Char>
    {
        public static readonly VersionUtf16Formatter Default = new VersionUtf16Formatter();
        public void Serialize(ref JsonWriter<Char> writer, Version? value)
        {
            if(value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            writer.WriteUtf16Version(value);
        }

		public Version? Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Version();
        }
    }

    public sealed class VersionUtf16ArrayFormatter : IJsonFormatter<Version?[]?, Char>
    {
        public static readonly VersionUtf16ArrayFormatter Default = new VersionUtf16ArrayFormatter();
        private static readonly VersionUtf16Formatter ElementFormatter = VersionUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Version?[]? value)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Version?[]? Deserialize(ref JsonReader<Char> reader)
        {
            Version?[]? temp = null;
            Version?[] result;
            try
            {
                temp = ArrayPool<Version?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Version?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class VersionUtf16ListFormatter : IJsonFormatter<List<Version?>?, Char>
    {
        public static readonly VersionUtf16ListFormatter Default = new VersionUtf16ListFormatter();
        private static readonly VersionUtf16Formatter ElementFormatter = VersionUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Version?>? value)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public List<Version?>? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Version?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class VersionUtf8Formatter : IJsonFormatter<Version?, Byte>
    {
        public static readonly VersionUtf8Formatter Default = new VersionUtf8Formatter();
        public void Serialize(ref JsonWriter<Byte> writer, Version? value)
        {
            if(value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            writer.WriteUtf8Version(value);
        }

		public Version? Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Version();
        }
    }

    public sealed class VersionUtf8ArrayFormatter : IJsonFormatter<Version?[]?, Byte>
    {
        public static readonly VersionUtf8ArrayFormatter Default = new VersionUtf8ArrayFormatter();
        private static readonly VersionUtf8Formatter ElementFormatter = VersionUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Version?[]? value)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Version?[]? Deserialize(ref JsonReader<Byte> reader)
        {
            Version?[]? temp = null;
            Version?[] result;
            try
            {
                temp = ArrayPool<Version?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Version?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class VersionUtf8ListFormatter : IJsonFormatter<List<Version?>?, Byte>
    {
        public static readonly VersionUtf8ListFormatter Default = new VersionUtf8ListFormatter();
        private static readonly VersionUtf8Formatter ElementFormatter = VersionUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Version?>? value)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public List<Version?>? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Version?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UriUtf16Formatter : IJsonFormatter<Uri?, Char>
    {
        public static readonly UriUtf16Formatter Default = new UriUtf16Formatter();
        public void Serialize(ref JsonWriter<Char> writer, Uri? value)
        {
            if(value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            writer.WriteUtf16Uri(value);
        }

		public Uri? Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Uri();
        }
    }

    public sealed class UriUtf16ArrayFormatter : IJsonFormatter<Uri?[]?, Char>
    {
        public static readonly UriUtf16ArrayFormatter Default = new UriUtf16ArrayFormatter();
        private static readonly UriUtf16Formatter ElementFormatter = UriUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Uri?[]? value)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Uri?[]? Deserialize(ref JsonReader<Char> reader)
        {
            Uri?[]? temp = null;
            Uri?[] result;
            try
            {
                temp = ArrayPool<Uri?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Uri?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UriUtf16ListFormatter : IJsonFormatter<List<Uri?>?, Char>
    {
        public static readonly UriUtf16ListFormatter Default = new UriUtf16ListFormatter();
        private static readonly UriUtf16Formatter ElementFormatter = UriUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Uri?>? value)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public List<Uri?>? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Uri?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UriUtf8Formatter : IJsonFormatter<Uri?, Byte>
    {
        public static readonly UriUtf8Formatter Default = new UriUtf8Formatter();
        public void Serialize(ref JsonWriter<Byte> writer, Uri? value)
        {
            if(value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            writer.WriteUtf8Uri(value);
        }

		public Uri? Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Uri();
        }
    }

    public sealed class UriUtf8ArrayFormatter : IJsonFormatter<Uri?[]?, Byte>
    {
        public static readonly UriUtf8ArrayFormatter Default = new UriUtf8ArrayFormatter();
        private static readonly UriUtf8Formatter ElementFormatter = UriUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Uri?[]? value)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Uri?[]? Deserialize(ref JsonReader<Byte> reader)
        {
            Uri?[]? temp = null;
            Uri?[] result;
            try
            {
                temp = ArrayPool<Uri?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Uri?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UriUtf8ListFormatter : IJsonFormatter<List<Uri?>?, Byte>
    {
        public static readonly UriUtf8ListFormatter Default = new UriUtf8ListFormatter();
        private static readonly UriUtf8Formatter ElementFormatter = UriUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Uri?>? value)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public List<Uri?>? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Uri?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
}